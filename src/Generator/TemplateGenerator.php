<?php

namespace MediaWiki\Extension\StructureSync\Generator;

use MediaWiki\Extension\StructureSync\Schema\CategoryModel;
use MediaWiki\Extension\StructureSync\Store\PageCreator;
use Title;

/**
 * Generates semantic and dispatcher templates for categories
 */
class TemplateGenerator {

	/** @var PageCreator */
	private $pageCreator;

	/**
	 * @param PageCreator|null $pageCreator
	 */
	public function __construct( PageCreator $pageCreator = null ) {
		$this->pageCreator = $pageCreator ?? new PageCreator();
	}

	/**
	 * Generate semantic template for a category
	 *
	 * @param CategoryModel $category
	 * @return string Template wikitext
	 */
	public function generateSemanticTemplate( CategoryModel $category ): string {
		$lines = [];

		$lines[] = '<noinclude>';
		$lines[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
		$lines[] = '<!-- This template is automatically regenerated -->';
		$lines[] = 'This is the semantic data template for [[Category:' . $category->getName() . ']].';
		$lines[] = '</noinclude><includeonly>{{#set:';

		// Add property assignments
		$allProperties = $category->getAllProperties();
		foreach ( $allProperties as $property ) {
			$paramName = $this->propertyToParameter( $property );
			$lines[] = '|' . $property . '={{{' . $paramName . '|}}}';
		}

		$lines[] = '}}';

		// Add category membership
		$lines[] = '[[Category:' . $category->getName() . ']]';

		// Add parent categories
		foreach ( $category->getParents() as $parent ) {
			$lines[] = '[[Category:' . $parent . ']]';
		}

		$lines[] = '</includeonly>';

		return implode( "\n", $lines );
	}

	/**
	 * Generate dispatcher template for a category
	 *
	 * @param CategoryModel $category
	 * @return string Template wikitext
	 */
	public function generateDispatcherTemplate( CategoryModel $category ): string {
		$lines = [];

		$lines[] = '<noinclude>';
		$lines[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
		$lines[] = '<!-- This template is automatically regenerated -->';
		$lines[] = 'This is the main template for [[Category:' . $category->getName() . ']].';
		$lines[] = '';
		$lines[] = 'It dispatches to:';
		$lines[] = '* [[Template:' . $category->getName() . '/semantic]] for semantic data storage';
		$lines[] = '* [[Template:' . $category->getName() . '/display]] for visual presentation';
		$lines[] = '</noinclude><includeonly>';

		// Include semantic template
		$lines[] = '{{' . $category->getName() . '/semantic';
		$allProperties = $category->getAllProperties();
		foreach ( $allProperties as $property ) {
			$paramName = $this->propertyToParameter( $property );
			$lines[] = '|' . $paramName . '={{{' . $paramName . '|}}}';
		}
		$lines[] = '}}';

		// Include display template
		$lines[] = '{{' . $category->getName() . '/display';
		foreach ( $allProperties as $property ) {
			$paramName = $this->propertyToParameter( $property );
			$lines[] = '|' . $paramName . '={{{' . $paramName . '|}}}';
		}
		$lines[] = '}}';

		$lines[] = '</includeonly>';

		return implode( "\n", $lines );
	}

	/**
	 * Update or create a template
	 *
	 * @param string $templateName Template name (without "Template:" prefix)
	 * @param string $content Template wikitext
	 * @return bool True on success
	 */
	public function updateTemplate( string $templateName, string $content ): bool {
		$title = $this->pageCreator->makeTitle( $templateName, NS_TEMPLATE );
		if ( $title === null ) {
			return false;
		}

		$summary = 'StructureSync: Auto-generated template';
		return $this->pageCreator->createOrUpdatePage( $title, $content, $summary );
	}

	/**
	 * Generate all templates for a category
	 *
	 * @param CategoryModel $category
	 * @return array Result with 'success' and 'errors' keys
	 */
	public function generateAllTemplates( CategoryModel $category ): array {
		$result = [
			'success' => true,
			'errors' => [],
		];

		$categoryName = $category->getName();

		// Generate semantic template
		$semanticContent = $this->generateSemanticTemplate( $category );
		if ( !$this->updateTemplate( $categoryName . '/semantic', $semanticContent ) ) {
			$result['success'] = false;
			$result['errors'][] = "Failed to create semantic template for $categoryName";
		}

		// Generate dispatcher template
		$dispatcherContent = $this->generateDispatcherTemplate( $category );
		if ( !$this->updateTemplate( $categoryName, $dispatcherContent ) ) {
			$result['success'] = false;
			$result['errors'][] = "Failed to create dispatcher template for $categoryName";
		}

		return $result;
	}

	/**
	 * Convert property name to template parameter name
	 *
	 * @param string $propertyName
	 * @return string
	 */
	private function propertyToParameter( string $propertyName ): string {
		// Remove "Has " prefix if present
		$param = $propertyName;
		if ( str_starts_with( $param, 'Has ' ) ) {
			$param = substr( $param, 4 );
		}

		// Convert to lowercase with underscores
		$param = strtolower( $param );
		$param = str_replace( ' ', '_', $param );

		return $param;
	}

	/**
	 * Check if semantic template exists for a category
	 *
	 * @param string $categoryName
	 * @return bool
	 */
	public function semanticTemplateExists( string $categoryName ): bool {
		$title = $this->pageCreator->makeTitle( $categoryName . '/semantic', NS_TEMPLATE );
		return $title !== null && $this->pageCreator->pageExists( $title );
	}

	/**
	 * Check if dispatcher template exists for a category
	 *
	 * @param string $categoryName
	 * @return bool
	 */
	public function dispatcherTemplateExists( string $categoryName ): bool {
		$title = $this->pageCreator->makeTitle( $categoryName, NS_TEMPLATE );
		return $title !== null && $this->pageCreator->pageExists( $title );
	}
}

