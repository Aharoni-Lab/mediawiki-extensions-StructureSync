<?php

namespace MediaWiki\Extension\StructureSync\Generator;

use MediaWiki\Extension\StructureSync\Schema\CategoryModel;
use MediaWiki\Extension\StructureSync\Schema\PropertyModel;
use MediaWiki\Extension\StructureSync\Schema\SubobjectModel;
use MediaWiki\Extension\StructureSync\Store\PageCreator;
use MediaWiki\Extension\StructureSync\Store\WikiPropertyStore;
use MediaWiki\Extension\StructureSync\Store\WikiSubobjectStore;
use MediaWiki\Extension\StructureSync\Util\NamingHelper;

/**
 * FormGenerator
 * --------------
 * Generates PageForms markup for category creation/editing forms.
 *
 * Features:
 * - Automatic field generation from CategoryModel schema
 * - Required and optional property sections
 * - Subobject repeatable blocks with minimum instances
 * - Namespace support for page creation
 * - Automatic hierarchy preview (when parent category property detected)
 *
 * Hierarchy Preview Integration:
 * When a category includes a "parent category" property (any property name
 * containing both "parent" and "category"), the generator automatically:
 * 1. Loads the JavaScript module for live preview
 * 2. Injects a hidden free text field for category membership
 * 3. Adds a preview container showing inheritance hierarchy
 * 4. Binds the preview to the parent category form field
 *
 * The preview updates in real-time as users select parent categories,
 * displaying the inheritance tree and inherited properties/subobjects.
 */
class FormGenerator {

    private PageCreator $pageCreator;
    private WikiPropertyStore $propertyStore;
    private PropertyInputMapper $inputMapper;
    private WikiSubobjectStore $subobjectStore;

    public function __construct(
        PageCreator $pageCreator = null,
        WikiPropertyStore $propertyStore = null,
        PropertyInputMapper $inputMapper = null,
        WikiSubobjectStore $subobjectStore = null
    ) {
        $this->pageCreator    = $pageCreator    ?? new PageCreator();
        $this->propertyStore  = $propertyStore  ?? new WikiPropertyStore();
        $this->inputMapper    = $inputMapper    ?? new PropertyInputMapper();
        $this->subobjectStore = $subobjectStore ?? new WikiSubobjectStore();
    }

    private function s(?string $v): string {
        return $v ?? '';
    }

    /**
     * Generate the full PageForms form for a category.
     */
    public function generateForm(CategoryModel $category): string {

        $name  = trim($category->getName());
        $label = trim($category->getLabel());

        if ($name === '') {
            throw new \InvalidArgumentException("Category name cannot be empty");
        }
        if ($label === '') {
            throw new \InvalidArgumentException("Category label cannot be empty");
        }

        $lines = [];

        /* ----------------------------------------------------------
         * <noinclude> Header
         * -------------------------------------------------------- */
        $lines[] = '<noinclude>';
        $lines[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $lines[] = '<!-- This form is automatically regenerated -->';
        $lines[] = 'This is the form for editing [[:Category:' . $this->s($name) . ']] pages.';

        $formInput = [
            'form=' . $this->s($name),
            'autocomplete on category=' . $this->s($name),
        ];

        if ($category->getTargetNamespace() !== null) {
            $formInput[] = 'namespace=' . $this->s($category->getTargetNamespace());
        }

        $lines[] = '{{#forminput:' . implode('|', $formInput) . '}}';

        $lines[] = '</noinclude><includeonly>';
        $lines[] = '';

        /* ----------------------------------------------------------
         * Template binding
         * -------------------------------------------------------- */
        $lines[] = '{{{for template|' . $this->s($name) . '}}}';
        $lines[] = '';

        /* ----------------------------------------------------------
         * Required + Optional property fields
         * -------------------------------------------------------- */
        $lines = array_merge($lines, $this->generatePropertySections($category));

        $lines[] = '{{{end template}}}';
        $lines[] = '';

        /* ----------------------------------------------------------
         * Hierarchy Preview (if parent category property exists)
         * 
         * Automatically injects:
         * 1. ResourceLoader module for JavaScript functionality
         * 2. Hidden free text field for category membership tags
         * 3. Preview container that displays hierarchy tree
         * 
         * The preview updates live as users select parent categories,
         * showing inheritance hierarchy and inherited properties.
         * -------------------------------------------------------- */
        $parentProp = $this->findParentCategoryProperty($category);
        if ($parentProp !== null) {

            // Load the form preview JavaScript module
            // Must be in <includeonly> so it loads when form is actually used
            $lines[] = '{{#structuresync_load_form_preview:}}';
            $lines[] = '';

            // Convert property name to parameter name for JavaScript field binding
            $parentParam = NamingHelper::propertyToParameter($parentProp);

            // Hidden free text field for automatic category tag injection
            // JavaScript populates this with [[Category:...]] tags based on selected parents
            $lines[] = '<!-- Auto-populated category membership field -->';
            $lines[] =
                '{{{standard input|free text|hidden|rows=1|placeholder=Parent categories will be added automatically|id=ss-parent-categories}}}';
            $lines[] = '';

            // Preview container that JavaScript will populate with hierarchy tree
            // data-parent-field attribute tells JS which form field to watch
            $lines[] = "'''Hierarchy Preview:'''" ;
            $lines[] = '<div id="ss-form-hierarchy-preview" data-parent-field="' . $this->s($parentParam) . '"></div>';
            $lines[] = '';
        }

        /* ----------------------------------------------------------
         * Subobject sections
         * -------------------------------------------------------- */
        $lines = array_merge($lines, $this->generateSubobjectSections($category));

        /* ----------------------------------------------------------
         * Summary + Buttons
         * -------------------------------------------------------- */
        $lines[] = '{{{standard input|summary}}}';
        $lines[] = '';
        $lines[] = '{{{standard input|save}}} '
                 . '{{{standard input|preview}}} '
                 . '{{{standard input|changes}}} '
                 . '{{{standard input|cancel}}}';
        $lines[] = '</includeonly>';

        return implode("\n", $lines);
    }

    /**
     * Required + optional sections.
     */
    private function generatePropertySections(CategoryModel $category): array {
        $required = $category->getRequiredProperties();
        $optional = $category->getOptionalProperties();

        sort($required);
        sort($optional);

        $out = [];

        if (!empty($required)) {
            $out[] = '=== Required Information ===';
            $out[] = '';
            foreach ($required as $prop) {
                $out = array_merge($out, $this->generateField($prop, $category, true));
            }
            $out[] = '';
        }

        if (!empty($optional)) {
            $out[] = '=== Optional Information ===';
            $out[] = '';
            foreach ($optional as $prop) {
                $out = array_merge($out, $this->generateField($prop, $category, false));
            }
            $out[] = '';
        }

        return $out;
    }

    /**
     * Single PageForms field block.
     */
    private function generateField(
        string $propertyName,
        CategoryModel $category,
        ?bool $isRequired = null
    ): array {

        $prop = $this->propertyStore->readProperty($propertyName)
            ?: new PropertyModel($propertyName, [ 'datatype' => 'Text' ]);

        // Determine if property is required
        $isReq = ($isRequired !== null)
            ? $isRequired
            : in_array($propertyName, $category->getRequiredProperties(), true);

        $input = $this->inputMapper->generateInputDefinition($prop, $isReq);
        $param = NamingHelper::propertyToParameter($propertyName);

        return [
            "'''{$prop->getLabel()}:'''",
            '{{{field|' . $param . '|property=' . $this->s($prop->getName()) . '|' . $input . '}}}',
            ''
        ];
    }

    /**
     * Subobject repeatable blocks.
     */
    private function generateSubobjectSections(CategoryModel $category): array {

        $required = $category->getRequiredSubobjects();
        $optional = $category->getOptionalSubobjects();

        $all = [];
        foreach ($required as $n) { $all[$n] = true; }
        foreach ($optional as $n) { if (!isset($all[$n])) $all[$n] = false; }

        if (empty($all)) {
            return [];
        }

        $out = [];

        foreach ($all as $subName => $isRequired) {

            $model = $this->subobjectStore->readSubobject($subName);
            if (!$model instanceof SubobjectModel) {
                wfLogWarning("StructureSync: Missing Subobject:$subName");
                continue;
            }

            $label = $this->s($model->getLabel() ?: $model->getName());

            $out[] = '=== ' . $label . ' ===';
            $out[] = '';

            $templateName = 'Subobject/' . $this->s($model->getName());

            $for = [ $templateName, 'multiple' ];
            if ($isRequired) {
                $for[] = 'minimum instances=1';
            }

            $out[] = '{{{for template|' . implode('|', $for) . '}}}';

            foreach (array_merge($model->getRequiredProperties(), $model->getOptionalProperties()) as $p) {
                $must = $model->isPropertyRequired($p);
                $out = array_merge($out, $this->generateField($p, $category, $must));
            }

            $out[] = '{{{end template}}}';
            $out[] = '';
        }

        return $out;
    }

    /* ----------------------------------------------------------
     * Save + utilities
     * -------------------------------------------------------- */

    public function updateForm(string $name, string $content): bool {

        if (trim($name) === '') {
            throw new \InvalidArgumentException("Form name cannot be empty");
        }

        $title = $this->pageCreator->makeTitle($name, \PF_NS_FORM);
        if (!$title) {
            wfLogWarning("StructureSync: Unable to create form title for '$name'");
            return false;
        }

        return $this->pageCreator->createOrUpdatePage(
            $title,
            $content,
            'StructureSync: Auto-generated form'
        );
    }

    public function generateAndSaveForm(CategoryModel $category): bool {
        try {
            $txt = $this->generateForm($category);
            return $this->updateForm($category->getName(), $txt);
        } catch (\Exception $e) {
            wfLogWarning(
                "StructureSync: Failed to gen/save form for {$category->getName()}: "
                . $e->getMessage()
            );
            return false;
        }
    }

    public function formExists(string $categoryName): bool {
        $t = $this->pageCreator->makeTitle($categoryName, \PF_NS_FORM);
        return $t && $this->pageCreator->pageExists($t);
    }

    /**
     * Find the parent category property in a category's schema.
     * 
     * Searches for any property name containing both "parent" and "category"
     * (case-insensitive) in either required or optional properties.
     * 
     * Matches common variations:
     *   - "Has parent category"
     *   - "Has_parent_category"
     *   - "Parent category"
     *   - "Parent categories"
     *   - Any other combination containing both words
     * 
     * This property is used to trigger automatic hierarchy preview functionality
     * in category creation forms.
     * 
     * @param CategoryModel $category The category to check
     * @return string|null The parent category property name if found, null otherwise
     */
    private function findParentCategoryProperty(CategoryModel $category): ?string {

        $props = array_merge(
            $category->getRequiredProperties(),
            $category->getOptionalProperties()
        );

        foreach ($props as $p) {
            $lc = strtolower($p);

            if (
                str_contains($lc, 'parent') &&
                str_contains($lc, 'category')
            ) {
                return $p;
            }
        }

        return null;
    }
}
