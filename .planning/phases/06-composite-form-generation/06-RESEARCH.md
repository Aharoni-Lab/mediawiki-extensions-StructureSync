# Phase 6: Composite Form Generation - Research

**Researched:** 2026-02-02
**Domain:** PageForms multi-template form generation, composite form architecture
**Confidence:** HIGH

## Summary

This phase creates CompositeFormGenerator to produce PageForms forms with multiple `{{{for template}}}` blocks, enabling single-form creation of multi-category pages. The core challenge is handling shared properties (appearing in multiple categories) while avoiding duplicate form fields.

PageForms natively supports multiple template blocks in a single form via sequential `{{{for template|Name}}}...{{{end template}}}` sections. Each section generates a template call on the saved page. The critical insight from Phase 4 and 5 is that conditional `#set` (already implemented) makes shared properties safe: when the same property appears in multiple templates, only the template receiving the form field value stores data; other templates receive empty parameters and skip storage via `#if` guards.

The architecture follows the single-category pattern established in FormGenerator: generate wikitext, save to Form: namespace, let PageForms handle rendering and submission. The new generator composes existing resolution (MultiCategoryResolver from Phase 5) with form field generation logic (reusable from FormGenerator).

**Primary recommendation:** Create CompositeFormGenerator that accepts ResolvedPropertySet, generates form with one `{{{for template}}}` block per category, shows shared properties once in first template section, and includes `[[Category:X]]` wikilinks for all selected categories.

## Standard Stack

No new libraries needed. This phase composes existing codebase components.

### Core Components (Existing)
| Component | Location | Purpose | Why Used |
|-----------|----------|---------|----------|
| MultiCategoryResolver | src/Schema/MultiCategoryResolver.php | Resolves properties across categories | Phase 5 - provides deduplicated property lists |
| ResolvedPropertySet | src/Schema/ResolvedPropertySet.php | Value object holding resolution results | Phase 5 - immutable result with source attribution |
| FormGenerator | src/Generator/FormGenerator.php | Single-category form generation | Existing - provides field generation patterns |
| PropertyInputMapper | src/Generator/PropertyInputMapper.php | Maps property types to PageForms input types | Existing - reusable for composite forms |
| PageCreator | src/Store/PageCreator.php | Wiki page CRUD operations | Existing - saves forms to Form: namespace |
| NamingHelper | src/Util/NamingHelper.php | Property name to parameter conversion | Existing - ensures consistent naming |

### PageForms Constructs (MediaWiki Extension)
| Construct | Syntax | Purpose |
|-----------|--------|---------|
| Multiple template blocks | `{{{for template\|Name}}}...{{{end template}}}` | Define multiple templates in one form |
| Template section label | `{{{for template\|Name\|label=Text}}}` | Visual grouping in form UI |
| Field with property binding | `{{{field\|param\|property=PropertyName\|...}}}` | Form input bound to SMW property |
| Standard category assignment | `[[Category:Name]]` free text | Assigns category on page save |

**Installation:**
No additional dependencies. PageForms already installed (extension dependency).

## Architecture Patterns

### Recommended Composite Form Structure

A composite form for categories Person and Employee:

```wikitext
<noinclude>
<!-- AUTO-GENERATED by SemanticSchemas - DO NOT EDIT MANUALLY -->
This form creates pages with categories: Person, Employee
{{#forminput:form=Person+Employee|autocomplete on category=Person}}
</noinclude><includeonly>

{{{info|page name=<page name>}}}

<!-- Shared properties section (first template owns these fields) -->
{{{for template|Person|label=Person Properties}}}

'''Shared fields:'''
{| class="formtable"
|-
! Full name: <span style="color:red;"> *</span>
| {{{field|full_name|property=Has full name|mandatory=true|...}}}
|-
! Email:
| {{{field|email|property=Has email|...}}}
|}

'''Person-specific fields:'''
{| class="formtable"
|-
! Biography:
| {{{field|biography|property=Has biography|...}}}
|}

{{{end template}}}

<!-- Second category section (no shared fields, conditional #set handles storage) -->
{{{for template|Employee|label=Employee Properties}}}

'''Employee-specific fields:'''
{| class="formtable"
|-
! Employee ID: <span style="color:red;"> *</span>
| {{{field|employee_id|property=Has employee ID|mandatory=true|...}}}
|-
! Department:
| {{{field|department|property=Has department|...}}}
|}

{{{end template}}}

'''Free text:'''
{{{standard input|free text|rows=10}}}

{{{standard input|summary}}}
{{{standard input|save}}} {{{standard input|preview}}} {{{standard input|changes}}} {{{standard input|cancel}}}

<!-- Category assignment via free text -->
[[Category:Person]]
[[Category:Employee]]

</includeonly>
```

**Key pattern:** Shared properties appear ONLY in first template section. Subsequent templates receive empty parameters, conditional `#set` (Phase 4) prevents overwrite.

### Pattern 1: Shared Property Placement

**What:** Properties appearing in multiple categories shown once in form.

**When to use:** Always for multi-category forms (otherwise duplicate fields).

**Algorithm:**
1. MultiCategoryResolver provides `ResolvedPropertySet`
2. Iterate categories in order
3. For first category: show ALL properties (required + optional)
4. For subsequent categories: show ONLY category-specific properties (filter out shared via `isSharedProperty()`)
5. Required/optional classification follows merged result (if required in ANY category, show as required)

**Example:**
```php
// From ResolvedPropertySet
$shared = []; // Properties where isSharedProperty() returns true
$categorySpecific = []; // Properties with single source

// First template section
foreach ($resolved->getAllProperties() as $prop) {
    $formFields[] = generateField($prop, $isRequired);
}

// Second+ template sections
foreach ($category->getAllProperties() as $prop) {
    if (!$resolved->isSharedProperty($prop)) {
        // Only show category-specific properties
        $formFields[] = generateField($prop, $isRequired);
    }
}
```

### Pattern 2: Category Assignment via Free Text

**What:** `[[Category:X]]` wikilinks placed in form's free text section.

**When to use:** All composite forms need explicit category assignment.

**Why:** PageForms doesn't automatically assign categories based on template usage. Without explicit wikilinks, page won't appear in category listings.

**Implementation:**
```wikitext
<!-- After all template sections, before standard inputs -->
[[Category:Person]]
[[Category:Employee]]
```

**Placement matters:** Must be in `<includeonly>` section, after `{{{end template}}}` blocks, typically before or after free text input.

### Pattern 3: Form Naming Convention

**What:** Composite forms named with category names joined by `+`.

**When to use:** Distinguishing composite forms from single-category forms.

**Convention:**
- Single category: `Form:Person`
- Composite: `Form:Person+Employee` (alphabetical order)
- Three categories: `Form:Category1+Category2+Category3`

**Rationale:**
- Alphabetical order ensures deterministic naming (Person+Employee === Employee+Person)
- `+` separator is URL-safe and visually distinct
- Autocomplete shows all available forms for category combination

### Pattern 4: Template Section Labels

**What:** `label=` parameter on `{{{for template}}}` creates visual grouping.

**Example:**
```wikitext
{{{for template|Person|label=Person Properties}}}
```

**Rendered as:** Bordered section with "Person Properties" header in form UI.

**Best practice:** Always label template sections in composite forms for clarity. Single-category forms may omit (redundant with form title).

### Pattern 5: Reuse Field Generation Logic

**What:** Property-to-field-wikitext generation is identical for single and composite forms.

**Strategy:** Extract reusable methods from FormGenerator:
- `generateTableField()` - Property to form field wikitext
- `generatePropertySection()` - Section with table wrapper
- `generateSubobjectSections()` - Subobject repeatable blocks

**Composition over inheritance:**
```php
class CompositeFormGenerator {
    private FormGenerator $formGenerator;

    public function generateCompositeForm(ResolvedPropertySet $resolved): string {
        // Use formGenerator->generateTableField() for each property
        // Assemble into multi-template structure
    }
}
```

**Alternatively, refactor FormGenerator:**
- Extract field generation to FormFieldRenderer (new class)
- FormGenerator and CompositeFormGenerator both use FormFieldRenderer
- Avoids duplication, maintains single responsibility

### Anti-Patterns to Avoid

- **Showing shared properties in multiple template sections:** Creates duplicate form fields, confusing UX, unclear which field "wins"
- **Omitting category wikilinks:** Page created but not assigned to categories, invisible in category listings
- **Inconsistent form naming:** `Person-Employee` vs `Person+Employee` vs `PersonEmployee` causes form lookup failures
- **Hardcoding category order:** Use alphabetical sort for deterministic naming
- **Generating separate forms per category combination:** Combinatorial explosion (10 categories = 1023 combinations), generate on-demand instead

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Property deduplication | Custom merging logic | MultiCategoryResolver (Phase 5) | Already handles C3 linearization, promotion, source attribution |
| Field generation | Custom wikitext builders | FormGenerator methods | Tested, handles all property types, supports subobjects |
| Parameter naming | Ad-hoc transformations | NamingHelper::propertyToParameter() | Consistent across templates/forms, tested |
| Form storage | Custom MediaWiki API calls | PageCreator::createOrUpdatePage() | Handles permissions, logging, caching |
| Property input types | Manual mapping | PropertyInputMapper::generateInputDefinition() | Maps all SMW datatypes to PageForms input types |

**Key insight:** FormGenerator already solves field generation for single categories. CompositeFormGenerator should COMPOSE existing logic, not reimplement.

## Common Pitfalls

### Pitfall 1: Duplicate Fields for Shared Properties

**What goes wrong:** Showing same property field in multiple template sections creates duplicate inputs in form. User sees "Full name" twice, unclear which to fill, confusing UX.

**Why it happens:** Naive approach iterates each category's properties independently without deduplication.

**How to avoid:**
1. Use `ResolvedPropertySet::isSharedProperty()` to identify shared properties
2. Show shared properties ONLY in first template section
3. Subsequent sections show only category-specific properties
4. Conditional `#set` (Phase 4) ensures correct storage

**Warning signs:** Form preview shows duplicate field labels. User bug reports "form has same field twice".

### Pitfall 2: Category Assignment Forgotten

**What goes wrong:** Form successfully creates page but page not assigned to any category. Page orphaned, doesn't appear in category listings, breaks navigation.

**Why it happens:** PageForms doesn't automatically assign categories based on template usage. Categories must be explicitly declared.

**How to avoid:**
1. Include `[[Category:X]]` wikilink for EVERY selected category
2. Place wikilinks in `<includeonly>` section (not `<noinclude>`)
3. Typically after all template sections, before or after free text
4. Verify with category existence check after page creation

**Warning signs:** Page created successfully but Special:Categories shows zero categories. Category page doesn't list new page.

### Pitfall 3: Field Parameter Name Collisions

**What goes wrong:** Two templates use same parameter name (e.g., both have `{{{name}}}`). PageForms can't distinguish which template should receive which value. Data may be duplicated or lost.

**Why it happens:** Parameter names are wiki-global within a form. PageForms uses parameter name to route values to templates.

**How to avoid:**
- **CURRENT ARCHITECTURE ALREADY SAFE:** SemanticSchemas uses `property=PropertyName` binding, not parameter-based routing
- Each field explicitly binds to SMW property: `{{{field|full_name|property=Has full name|...}}}`
- Property names are wiki-global (Phase 5 finding), so no collision possible
- Parameter names (e.g., `full_name`) derived from property names via NamingHelper, ensuring consistency

**Verification:** Check FormGenerator line 251: `property=' . $this->s( $prop->getName() )` confirms property binding.

**Warning signs:** Would only occur if switching to parameter-only fields without `property=` binding. Current architecture immune.

### Pitfall 4: Required Field Classification Mismatch

**What goes wrong:** Property required in one category but optional in another. Form shows as optional (no red asterisk), user submits without filling, validation fails on one category's template.

**Why it happens:** Unclear which category's requirement "wins" when merging.

**How to avoid:**
- **ALREADY SOLVED IN PHASE 5:** MultiCategoryResolver promotes to required if ANY category requires it
- ResolvedPropertySet stores merged required/optional classification
- Use `$resolved->getRequiredProperties()` for form field mandatory marking
- If property in required list, set `mandatory=true` in field definition

**Verification:** Phase 5 tests confirm promotion behavior (RESO-06 requirement).

**Warning signs:** Form allows submission with empty required field. Validation error after submission.

### Pitfall 5: Subobject Section Duplication

**What goes wrong:** Subobject shared across categories appears twice in form, creating duplicate repeatable sections. User confusion, potential data duplication.

**Why it happens:** Subobjects handled separately from properties in MultiCategoryResolver. Deduplication logic for subobjects needs same pattern as properties.

**How to avoid:**
1. Use `ResolvedPropertySet::isSharedSubobject()` (mirrors isSharedProperty)
2. Show shared subobjects in first template section only
3. Category-specific subobjects in their respective sections
4. Follow same placement strategy as properties

**Warning signs:** Form preview shows duplicate subobject tables (e.g., two "Authors" sections).

### Pitfall 6: Form Naming Conflicts with Single-Category Forms

**What goes wrong:** Composite form named `Person` overwrites existing single-category `Form:Person`, breaking single-category page creation.

**Why it happens:** Form namespace is flat, composite and single-category forms share namespace.

**How to avoid:**
1. Naming convention: composite forms ALWAYS use `+` separator (e.g., `Person+Employee`)
2. Single-category forms remain unchanged (e.g., `Person`)
3. Never name composite form with single category name
4. Even single-category composite (redundant case) should be `Person+Person` or rejected

**Warning signs:** Existing single-category form stops working after composite form generation. FormEdit loads unexpected form definition.

### Pitfall 7: `#forminput` Autocomplete Ambiguity

**What goes wrong:** `{{#forminput:form=Person+Employee|autocomplete on category=Person}}` only autocompletes Person pages, not Employee pages.

**Why it happens:** `autocomplete on category=` parameter accepts single category, not multiple.

**How to avoid:**
- Omit `autocomplete on category=` for composite forms (autocomplete disabled)
- OR use primary category only (first in alphabetical order)
- OR use `autocomplete on namespace=` if target namespace set
- Document limitation: autocomplete less useful for multi-category pages

**Alternative:** Create dedicated Special page for multi-category page creation (Phase 8) with better autocomplete UX.

**Warning signs:** Autocomplete suggests irrelevant pages or no pages.

## Code Examples

### Example 1: CompositeFormGenerator Class Skeleton

```php
<?php

namespace MediaWiki\Extension\SemanticSchemas\Generator;

use MediaWiki\Extension\SemanticSchemas\Schema\ResolvedPropertySet;
use MediaWiki\Extension\SemanticSchemas\Store\PageCreator;

/**
 * Generates composite PageForms forms for multi-category pages.
 *
 * Produces forms with multiple {{{for template}}} blocks, one per category.
 * Shared properties appear once in first template section.
 */
class CompositeFormGenerator {

    private PageCreator $pageCreator;
    private FormGenerator $formGenerator; // Reuse field generation

    public function __construct(
        ?PageCreator $pageCreator = null,
        ?FormGenerator $formGenerator = null
    ) {
        $this->pageCreator = $pageCreator ?? new PageCreator();
        $this->formGenerator = $formGenerator ?? new FormGenerator();
    }

    /**
     * Generate composite form from resolved property set.
     *
     * @param ResolvedPropertySet $resolved Resolution result from MultiCategoryResolver
     * @return string Form wikitext
     */
    public function generateCompositeForm(ResolvedPropertySet $resolved): string {
        $categories = $resolved->getCategoryNames();
        if (count($categories) < 2) {
            throw new \InvalidArgumentException(
                "Composite form requires 2+ categories, got " . count($categories)
            );
        }

        $lines = [];

        // Header
        $lines[] = '<noinclude>';
        $lines[] = '<!-- AUTO-GENERATED by SemanticSchemas - DO NOT EDIT MANUALLY -->';
        $lines[] = 'Composite form for categories: ' . implode(', ', $categories);
        $lines[] = $this->generateFormInput($categories);
        $lines[] = '</noinclude><includeonly>';
        $lines[] = '';
        $lines[] = '{{{info|page name=<page name>}}}';
        $lines[] = '';

        // Template sections
        $lines = array_merge($lines, $this->generateTemplateSections($resolved));

        // Free text
        $lines[] = "'''Free text:'''";
        $lines[] = '{{{standard input|free text|rows=10}}}';
        $lines[] = '';

        // Category assignments
        foreach ($categories as $category) {
            $lines[] = '[[Category:' . $category . ']]';
        }
        $lines[] = '';

        // Standard inputs
        $lines[] = '{{{standard input|summary}}}';
        $lines[] = '{{{standard input|save}}} {{{standard input|preview}}} {{{standard input|changes}}} {{{standard input|cancel}}}';
        $lines[] = '</includeonly>';

        return implode("\n", $lines);
    }

    private function generateFormInput(array $categories): string {
        $formName = $this->getCompositeFormName($categories);
        // Primary category for autocomplete (first alphabetically)
        $primaryCategory = $categories[0];
        return '{{#forminput:form=' . $formName . '|autocomplete on category=' . $primaryCategory . '}}';
    }

    private function generateTemplateSections(ResolvedPropertySet $resolved): array {
        $categories = $resolved->getCategoryNames();
        $lines = [];

        foreach ($categories as $index => $categoryName) {
            $isFirst = ($index === 0);
            $lines = array_merge(
                $lines,
                $this->generateCategorySection($categoryName, $resolved, $isFirst)
            );
        }

        return $lines;
    }

    private function generateCategorySection(
        string $categoryName,
        ResolvedPropertySet $resolved,
        bool $isFirst
    ): array {
        // Implementation: generate {{{for template|X|label=...}}} block
        // If first: show all properties (shared + specific)
        // If not first: show only category-specific properties (filter shared)
        // Use formGenerator->generateTableField() for each property

        // Pseudocode:
        // $properties = $isFirst
        //     ? $resolved->getAllProperties()
        //     : array_filter($properties, fn($p) => !$resolved->isSharedProperty($p));

        return []; // Placeholder
    }

    /**
     * Generate composite form name from category names.
     *
     * @param array $categories Category names
     * @return string Alphabetically sorted, joined with +
     */
    public function getCompositeFormName(array $categories): string {
        $sorted = $categories;
        sort($sorted);
        return implode('+', $sorted);
    }

    /**
     * Save composite form to Form: namespace.
     *
     * @param ResolvedPropertySet $resolved
     * @return bool Success
     */
    public function generateAndSaveCompositeForm(ResolvedPropertySet $resolved): bool {
        $formName = $this->getCompositeFormName($resolved->getCategoryNames());
        $content = $this->generateCompositeForm($resolved);

        $title = $this->pageCreator->makeTitle($formName, \PF_NS_FORM);
        if (!$title) {
            return false;
        }

        return $this->pageCreator->createOrUpdatePage(
            $title,
            $content,
            'SemanticSchemas: Auto-generated composite form'
        );
    }
}
```

### Example 2: Category-Specific Property Filtering

```php
/**
 * Filter properties to category-specific subset (exclude shared).
 *
 * @param array $allProperties All property names from a category
 * @param ResolvedPropertySet $resolved Resolution result
 * @return array Category-specific properties only
 */
private function getCategorySpecificProperties(
    array $allProperties,
    ResolvedPropertySet $resolved
): array {
    return array_filter(
        $allProperties,
        fn($prop) => !$resolved->isSharedProperty($prop)
    );
}
```

### Example 3: Complete Composite Form Output (Two Categories)

For Person (properties: Full name, Email, Biography) and Employee (properties: Full name, Employee ID, Department):

Shared property: Full name
Person-specific: Email, Biography
Employee-specific: Employee ID, Department

```wikitext
<noinclude>
<!-- AUTO-GENERATED by SemanticSchemas - DO NOT EDIT MANUALLY -->
Composite form for categories: Employee, Person
{{#forminput:form=Employee+Person|autocomplete on category=Employee}}
</noinclude><includeonly>

{{{info|page name=<page name>}}}

{{{for template|Employee|label=Employee Properties}}}

'''Required fields:'''
{| class="formtable"
|-
! Full name:<span style="color:red;"> *</span>
| {{{field|full_name|property=Has full name|mandatory=true|input type=text}}}
|-
! Employee ID:<span style="color:red;"> *</span>
| {{{field|employee_id|property=Has employee ID|mandatory=true|input type=text}}}
|}

'''Optional fields:'''
{| class="formtable"
|-
! Department:
| {{{field|department|property=Has department|input type=text}}}
|}

{{{end template}}}

{{{for template|Person|label=Person Properties}}}

'''Optional fields:'''
{| class="formtable"
|-
! Email:
| {{{field|email|property=Has email|input type=text with autocomplete}}}
|-
! Biography:
| {{{field|biography|property=Has biography|input type=textarea|rows=5}}}
|}

{{{end template}}}

'''Free text:'''
{{{standard input|free text|rows=10}}}

[[Category:Employee]]
[[Category:Person]]

{{{standard input|summary}}}
{{{standard input|save}}} {{{standard input|preview}}} {{{standard input|changes}}} {{{standard input|cancel}}}

</includeonly>
```

**Note:** Full name shown in Employee section (first alphabetically), not duplicated in Person section.

## State of the Art

| Pattern | Legacy Approach | Current Best Practice | When Changed | Impact |
|---------|----------------|----------------------|--------------|--------|
| Multi-category pages | Manual template calls, separate forms | Composite forms with multiple `{{{for template}}}` blocks | PageForms 2.0+ (2012) | Single form for multi-category creation |
| Shared property handling | Duplicate fields or complex JavaScript | Conditional `#set` in templates | SMW 1.9.0 (2014, `#if` pattern formalized) | No duplicate fields, safe storage |
| Property deduplication | Manual tracking in forms | ResolvedPropertySet (Phase 5) | SemanticSchemas v0.2.0 (2026) | Automated, tested resolution |
| Form naming | Inconsistent conventions | `Category1+Category2` alphabetical | SemanticSchemas v0.2.0 (2026) | Deterministic, conflict-free |

**Deprecated/outdated:**
- **Separate forms per category combination:** Combinatorial explosion, maintenance nightmare. Generate composite forms on-demand.
- **JavaScript-based field hiding:** Fragile, breaks without JS, accessibility issues. Server-side property resolution preferred.
- **Parameter-based template routing:** Ambiguous with shared parameter names. Use `property=` binding (current FormGenerator pattern).

## Open Questions

1. **Subobject handling in composite forms**
   - What we know: ResolvedPropertySet tracks shared/specific subobjects symmetrically with properties
   - What's unclear: Should subobject sections be grouped with their category template section or separate?
   - Recommendation: Group subobjects with category section (same pattern as properties). First category shows shared subobjects, subsequent show specific.

2. **Form generation trigger point**
   - What we know: Composite forms can be generated on-demand (Phase 6 scope)
   - What's unclear: Should forms be pre-generated for all combinations or lazy-generated on first use?
   - Recommendation: Lazy generation (Phase 8 UI triggers). Pre-generation has combinatorial explosion (10 categories = 1023 forms). Generate when user selects category combination in UI.

3. **Existing page editing with composite forms**
   - What we know: New page creation works with composite forms
   - What's unclear: If page exists with Category A, user wants to add Category B, which form to use?
   - Recommendation: Phase 8 concern (UI). Phase 6 generates forms, doesn't handle form selection logic. Document limitation: composite forms primarily for new page creation.

4. **Namespace targeting in composite forms**
   - What we know: Single-category forms support `{{{info|page name=Namespace:<page name>}}}`
   - What's unclear: If categories target different namespaces, which namespace wins?
   - Recommendation: Validate during resolution (error if namespace mismatch). Only generate composite forms if all categories have same target namespace (or all null). Document constraint.

5. **Free text section placement**
   - What we know: Current FormGenerator places free text after subobject sections
   - What's unclear: Best UX placement in composite forms (after all categories? Between categories?)
   - Recommendation: After all template sections, before category assignments. Consistent with single-category pattern, clear separation.

## Sources

### Primary (HIGH confidence)
- **Codebase analysis**: `src/Generator/FormGenerator.php` — Complete single-category form generation patterns (lines 44-412)
- **Codebase analysis**: `src/Schema/MultiCategoryResolver.php` — Property resolution algorithm (Phase 5)
- **Codebase analysis**: `src/Schema/ResolvedPropertySet.php` — Resolution result API (getRequiredProperties, isSharedProperty, etc.)
- **Codebase analysis**: `src/Generator/TemplateGenerator.php` — Conditional `#set` implementation (Phase 4, lines 55-85)
- **Codebase analysis**: `src/Util/NamingHelper.php` — Property to parameter naming (propertyToParameter method)
- **Codebase analysis**: `.planning/research/ARCHITECTURE.md` — Multi-template form structure examples (lines 170-196)
- **Codebase analysis**: `.planning/research/PITFALLS.md` — Property collision patterns (lines 13-56)
- **Codebase analysis**: `.planning/phases/04-conditional-templates/04-RESEARCH.md` — Conditional `#set` pattern verification

### Secondary (MEDIUM confidence)
- [Extension:Page Forms/Defining forms - MediaWiki](https://www.mediawiki.org/wiki/Extension:Page_Forms/Defining_forms) — Multiple `{{{for template}}}` blocks confirmed supported
- [Extension:Page Forms/Page Forms and templates - MediaWiki](https://www.mediawiki.org/wiki/Extension:Page_Forms/Page_Forms_and_templates) — Template and property binding patterns
- [Working with MediaWiki - Chapter 17](https://workingwithmediawiki.com/book/chapter17.html) — PageForms form structure and syntax
- WebSearch results (2026-02-02) — Multiple template syntax, label parameter, field property binding

### Tertiary (LOW confidence)
- Community discussions on shared property handling (WebSearch results, no official documentation found)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — No new dependencies, composes existing codebase components
- Architecture: HIGH — Multi-template syntax verified in PageForms docs, conditional `#set` from Phase 4 solves collision
- Pitfalls: HIGH — Property collision already solved (Phase 4), category assignment pattern known
- Subobject handling: MEDIUM — Same pattern as properties should work, needs testing
- Form naming: HIGH — Alphabetical `+` convention is deterministic and conflict-free
- Existing page editing: MEDIUM — Edge case, deferred to Phase 8 UI

**Research date:** 2026-02-02
**Valid until:** 2026-03-02 (PageForms syntax stable, codebase architecture from Phase 4-5)
