---
phase: 09-state-management-refactor
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/Special/SpecialSemanticSchemas.php
  - src/Schema/OntologyInspector.php
  - maintenance/regenerateArtifacts.php
autonomous: true

must_haves:
  truths:
    - "After generation, template hashes are stored keyed by template page name (Template:X/semantic, Template:X, Form:X)"
    - "Each template hash entry is attributed to the category that generated it"
    - "Validation detects stale templates by comparing stored template hashes against regenerated content hashes"
    - "Multi-category pages do not trigger false-positive dirty warnings when one category schema changes"
    - "Maintenance script updates template hashes after regeneration"
  artifacts:
    - path: "src/Special/SpecialSemanticSchemas.php"
      provides: "computeAllTemplateHashes method + wiring in processGenerate"
      contains: "computeAllTemplateHashes"
    - path: "src/Schema/OntologyInspector.php"
      provides: "Template hash validation in validateWikiState"
      contains: "getStaleTemplates"
    - path: "maintenance/regenerateArtifacts.php"
      provides: "Template hash updates after CLI regeneration"
      contains: "setTemplateHashes"
  key_links:
    - from: "src/Special/SpecialSemanticSchemas.php"
      to: "src/Store/StateManager.php"
      via: "setTemplateHashes call in processGenerate"
      pattern: "stateManager->setTemplateHashes"
    - from: "src/Schema/OntologyInspector.php"
      to: "src/Store/StateManager.php"
      via: "getStaleTemplates call in validateWikiState"
      pattern: "stateManager->getStaleTemplates"
    - from: "src/Special/SpecialSemanticSchemas.php"
      to: "src/Store/PageHashComputer.php"
      via: "hashContentString for template content"
      pattern: "hashComputer->hashContentString"
---

<objective>
Wire template-level hashing into the generation flow, validation, and maintenance script.

Purpose: Plan 01 added the StateManager/PageHashComputer infrastructure. This plan connects it to the actual generation pipeline in SpecialSemanticSchemas (so template hashes are computed and stored during generation), to OntologyInspector (so validation checks template staleness), and to the maintenance script (so CLI regeneration also updates template hashes). This completes the STATE-01 and STATE-02 requirements -- multi-category pages will have per-template tracking, eliminating false-positive dirty detection.

Output: Full end-to-end template hash flow from generation through validation, including maintenance CLI.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-state-management-refactor/09-RESEARCH.md
@.planning/phases/09-state-management-refactor/09-01-SUMMARY.md

@src/Special/SpecialSemanticSchemas.php
@src/Schema/OntologyInspector.php
@src/Store/StateManager.php
@src/Store/PageHashComputer.php
@src/Generator/TemplateGenerator.php
@src/Generator/FormGenerator.php
@maintenance/regenerateArtifacts.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add computeAllTemplateHashes and wire into processGenerate</name>
  <files>
    src/Special/SpecialSemanticSchemas.php
  </files>
  <action>
**Add new private method `computeAllTemplateHashes`** near the existing `computeAllSchemaHashes()` method (after it, around line 1347):

```php
/**
 * Compute hashes for all generated template and form artifacts.
 *
 * Hashes the actual generated wikitext content (not schema model data)
 * and keys entries by template page name for per-template dirty detection.
 *
 * @param array $categories Array of CategoryModel objects
 * @param TemplateGenerator $templateGenerator
 * @param FormGenerator $formGenerator
 * @param InheritanceResolver $resolver
 * @return array<string, array> Map of template page name => hash data
 */
private function computeAllTemplateHashes(
    array $categories,
    TemplateGenerator $templateGenerator,
    FormGenerator $formGenerator,
    InheritanceResolver $resolver
): array {
```

Implementation:
1. Create `$hashComputer = new PageHashComputer()`
2. Initialize `$templateHashes = []`
3. Iterate `$categories`. For each category:
   - Get `$effective = $resolver->getEffectiveCategory( $category->getName() )`
   - Get `$name = $category->getName()`
   - Generate and hash semantic template: `$content = $templateGenerator->generateSemanticTemplate( $effective )` then store `$templateHashes["Template:$name/semantic"] = ['generated' => $hashComputer->hashContentString( $content ), 'category' => $name]`
   - Generate and hash dispatcher template: `$content = $templateGenerator->generateDispatcherTemplate( $effective )` then store `$templateHashes["Template:$name"] = ['generated' => $hashComputer->hashContentString( $content ), 'category' => $name]`
   - Generate and hash form: `$content = $formGenerator->generateForm( $effective )` then store `$templateHashes["Form:$name"] = ['generated' => $hashComputer->hashContentString( $content ), 'category' => $name]`
   - Wrap each generation call in try/catch so a single failure doesn't abort all hash computation. Log warnings via `wfLogWarning()` on failure (matching existing pattern in processGenerate).
4. Return `$templateHashes`

NOTE: Do NOT hash display templates (Template:X/display) -- they are user-editable stubs per research recommendation. Do NOT hash subobject templates for now -- they are category-independent artifacts already tracked via the existing pageHashes flow.

**Wire into processGenerate:**

In the `processGenerate()` method, locate the block around line 1460-1466:
```php
$pageHashes = $this->computeAllSchemaHashes();
if ( !empty( $pageHashes ) ) {
    $stateManager = new StateManager();
    $stateManager->setPageHashes( $pageHashes );
    $stateManager->clearDirty();
}
```

Add template hash computation AFTER the existing page hash block (do not modify it). The `$templateGenerator`, `$formGenerator` variables already exist in scope from earlier in processGenerate. The `$resolver` variable also exists. The `$categories` variable is the array from `$this->getTargetCategories()`.

Add:
```php
$templateHashes = $this->computeAllTemplateHashes(
    $categories, $templateGenerator, $formGenerator, $resolver
);
if ( !empty( $templateHashes ) ) {
    $stateManager->setTemplateHashes( $templateHashes );
}
```

Note: `$stateManager` was already created in the page hash block above. If the page hash block's `!empty` guard was false and `$stateManager` doesn't exist, create it: move `$stateManager = new StateManager()` above both blocks, or use the existing conditional. The simplest approach: move `$stateManager` creation before the `$pageHashes` block so both blocks can use it.

Also update the `logOperation` call to include template hash count:
```php
'templatesHashed' => count( $templateHashes ),
```
  </action>
  <verify>
Run `composer test` -- all tests and linting pass. Verify the new method exists via grep: `grep -n 'computeAllTemplateHashes' src/Special/SpecialSemanticSchemas.php`
  </verify>
  <done>
processGenerate computes both page-level hashes (existing) and template-level hashes (new) after generation, storing both via StateManager. Template hashes are keyed by template page name with category attribution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add template hash validation to OntologyInspector + maintenance script</name>
  <files>
    src/Schema/OntologyInspector.php
    maintenance/regenerateArtifacts.php
  </files>
  <action>
**OntologyInspector changes:**

In `validateWikiState()`, after the existing schema hash comparison block (after line ~217 where `$modified` is finalized), add template hash checking:

1. Add `use` imports at top of file for TemplateGenerator, FormGenerator, InheritanceResolver (if not already present)
2. After the existing page hash comparison, add:

```php
// Template-level staleness detection
$storedTemplateHashes = $this->stateManager->getTemplateHashes();
if ( !empty( $storedTemplateHashes ) ) {
    $currentTemplateHashes = $this->computeCurrentTemplateHashes();
    $staleTemplates = $this->stateManager->getStaleTemplates( $currentTemplateHashes );

    if ( !empty( $staleTemplates ) ) {
        $warnings[] = 'Templates needing regeneration: ' . implode( ', ', $staleTemplates );
    }
}
```

3. Add private method `computeCurrentTemplateHashes(): array`:
   - Create TemplateGenerator, FormGenerator, InheritanceResolver instances
   - Get all categories from `$this->categoryStore->getAllCategories()`
   - Build category map for InheritanceResolver (same pattern as SpecialSemanticSchemas::buildCategoryMap)
   - Create `$hashComputer = new PageHashComputer()`
   - For each category: get effective category via resolver, generate semantic template content, dispatcher content, and form content. Hash each with `$hashComputer->hashContentString()`.
   - Key entries by template page name with category attribution (same structure as computeAllTemplateHashes in SpecialSemanticSchemas)
   - Return the hash array
   - Wrap each generation in try/catch (defensive, matching existing patterns)

**Maintenance script changes:**

In `regenerateArtifacts.php`, at the end of the `execute()` method (line ~74, before `$this->output( "\nRegeneration complete!\n" )`):

1. Add `use` statements at top for StateManager, PageHashComputer
2. After the category regeneration loop, add template hash computation:

```php
// Update template hashes after regeneration
$this->output( "Updating template hashes...\n" );
$stateManager = new StateManager();
$hashComputer = new PageHashComputer();
$templateHashes = [];

$allCategories = $categoryStore->getAllCategories();
$categoryMap = [];
foreach ( $allCategories as $cat ) {
    $categoryMap[$cat->getName()] = $cat;
}
$resolver = new InheritanceResolver( $categoryMap );

foreach ( $allCategories as $category ) {
    $name = $category->getName();
    try {
        $effective = $resolver->getEffectiveCategory( $name );

        $semanticContent = $templateGenerator->generateSemanticTemplate( $effective );
        $templateHashes["Template:$name/semantic"] = [
            'generated' => $hashComputer->hashContentString( $semanticContent ),
            'category' => $name,
        ];

        $dispatcherContent = $templateGenerator->generateDispatcherTemplate( $effective );
        $templateHashes["Template:$name"] = [
            'generated' => $hashComputer->hashContentString( $dispatcherContent ),
            'category' => $name,
        ];

        $formContent = $formGenerator->generateForm( $effective );
        $templateHashes["Form:$name"] = [
            'generated' => $hashComputer->hashContentString( $formContent ),
            'category' => $name,
        ];
    } catch ( \Throwable $e ) {
        $this->output( "  Warning: Could not hash templates for $name: " . $e->getMessage() . "\n" );
    }
}

if ( !empty( $templateHashes ) ) {
    $stateManager->setTemplateHashes( $templateHashes );
    $this->output( "  Updated " . count( $templateHashes ) . " template hashes\n" );
}
```

Note for maintenance script: if `$categoryName` was specified (single category mode), only compute hashes for that specific category, not all. Wrap the hash block in a condition that checks whether specific or all categories were regenerated. For single-category: only hash that one category's templates. For all: hash all.

Add the necessary `use` imports at the top of the file for StateManager, PageHashComputer, InheritanceResolver (InheritanceResolver is already imported).
  </action>
  <verify>
Run `composer test` -- all tests and linting pass. Verify new methods via grep:
- `grep -n 'computeCurrentTemplateHashes\|getStaleTemplates' src/Schema/OntologyInspector.php`
- `grep -n 'setTemplateHashes\|templateHashes' maintenance/regenerateArtifacts.php`
  </verify>
  <done>
OntologyInspector.validateWikiState() checks template hashes and reports stale templates as warnings. Maintenance script computes and stores template hashes after regeneration. Full end-to-end template hash flow is complete.
  </done>
</task>

</tasks>

<verification>
- `composer test` passes (parallel-lint, minus-x, phpcs, phpunit)
- SpecialSemanticSchemas::processGenerate stores both page hashes AND template hashes
- OntologyInspector::validateWikiState checks template hashes for staleness
- maintenance/regenerateArtifacts.php updates template hashes
- Template hashes are keyed by template page name (Template:X/semantic, Template:X, Form:X)
- Each hash entry has category attribution
- Existing pageHashes flow is completely untouched (backward compatible)
</verification>

<success_criteria>
- STATE-01 (complete): StateManager tracks hash for each template independently
- STATE-02 (complete): Multi-category pages do not trigger false-positive dirty warnings (per-template keying means changing Category:Person only flags Template:Person/* as stale, not Template:Employee/*)
- STATE-03 (complete): Existing single-category state tracking continues working (pageHashes preserved, template hashes additive)
- State JSON correctly stores and retrieves template-level hashes (templateHashes section alongside pageHashes)
</success_criteria>

<output>
After completion, create `.planning/phases/09-state-management-refactor/09-02-SUMMARY.md`
</output>
