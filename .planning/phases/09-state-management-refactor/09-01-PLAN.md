---
phase: 09-state-management-refactor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Store/StateManager.php
  - src/Store/PageHashComputer.php
  - tests/phpunit/unit/Store/StateManagerTest.php
autonomous: true

must_haves:
  truths:
    - "StateManager stores and retrieves template-level hashes independently from page-level hashes"
    - "Existing pageHashes continue working identically after adding templateHashes"
    - "PageHashComputer can hash raw content strings (not just model arrays)"
    - "Stale template detection correctly identifies templates whose generated content changed"
  artifacts:
    - path: "src/Store/StateManager.php"
      provides: "Template hash CRUD + stale detection"
      exports: ["setTemplateHashes", "getTemplateHashes", "getStaleTemplates"]
    - path: "src/Store/PageHashComputer.php"
      provides: "Public content hashing for generated template strings"
      exports: ["hashContentString"]
    - path: "tests/phpunit/unit/Store/StateManagerTest.php"
      provides: "Unit tests for template hash methods"
      contains: "testSetTemplateHashes"
  key_links:
    - from: "src/Store/StateManager.php"
      to: "getDefaultState"
      via: "templateHashes key in default state"
      pattern: "'templateHashes'\\s*=>\\s*\\[\\]"
    - from: "src/Store/StateManager.php"
      to: "getState()"
      via: "array_merge preserves both pageHashes and templateHashes"
      pattern: "array_merge.*getDefaultState"
---

<objective>
Add template-level hash tracking infrastructure to StateManager and PageHashComputer.

Purpose: StateManager currently only tracks schema entity hashes (Category:X, Property:Y) via pageHashes. This plan adds a parallel templateHashes section that tracks generated artifact hashes (Template:X/semantic, Template:X, Form:X) keyed by template page name with category attribution. This is the foundation for eliminating false-positive dirty detection on multi-category pages.

Output: StateManager with setTemplateHashes/getTemplateHashes/getStaleTemplates methods, PageHashComputer with public content string hashing, and comprehensive unit tests.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-state-management-refactor/09-RESEARCH.md

@src/Store/StateManager.php
@src/Store/PageHashComputer.php
@tests/phpunit/unit/Store/StateManagerTest.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add templateHashes to StateManager + hashContentString to PageHashComputer</name>
  <files>
    src/Store/StateManager.php
    src/Store/PageHashComputer.php
  </files>
  <action>
**StateManager changes:**

1. Add `'templateHashes' => []` to `getDefaultState()` return array (after `'pageHashes' => []`). The existing `array_merge($this->getDefaultState(), $state)` in `getState()` handles backward compatibility automatically -- old state JSON without templateHashes gets an empty array merged in.

2. Add `getTemplateHashes(): array` public method:
   - Reads state via `$this->getState()`
   - Returns `$state['templateHashes'] ?? []`
   - Mirrors existing `getPageHashes()` pattern

3. Add `setTemplateHashes( array $hashes ): bool` public method:
   - Reads state via `$this->getState()`
   - Gets existing `$templateHashes = $state['templateHashes'] ?? []`
   - Iterates `$hashes` and merges each entry: `$templateHashes[$templateName] = $hashData`
   - Each entry is an associative array with structure: `['generated' => 'sha256:...', 'category' => 'CategoryName']` for single-category templates, or `['generated' => 'sha256:...', 'categories' => ['Cat1', 'Cat2']]` for composite forms
   - Sets `$state['templateHashes'] = $templateHashes`
   - Sets `$state['generated'] = wfTimestamp( TS_ISO_8601 )`
   - Saves and returns result
   - Pattern mirrors `setPageHashes()` but simpler since entries are always associative arrays (no string-to-struct conversion needed)

4. Add `getStaleTemplates( array $currentTemplateHashes ): array` public method:
   - Reads state via `$this->getState()`
   - Gets stored `$stored = $state['templateHashes'] ?? []`
   - Iterates `$currentTemplateHashes`: if stored hash for that template name differs from current `'generated'` value, add to `$stale[]`
   - Also iterates `$stored`: if a stored template is NOT in `$currentTemplateHashes`, add to `$stale[]` (deleted/removed templates)
   - Returns `$stale` array of template page names
   - Pattern mirrors `comparePageHashes()` but uses the `'generated'` key from the associative array entries

**PageHashComputer changes:**

5. Add `hashContentString( string $content ): string` public method:
   - Simply calls and returns `$this->hashContent( $content )`
   - This exposes the private `hashContent()` method for external callers who need to hash raw generated template/form wikitext strings
   - The existing `hashContent()` already adds the `sha256:` prefix

Do NOT modify any existing methods. Do NOT change `pageHashes` behavior. All changes are additive.
  </action>
  <verify>
Run `composer test` -- all existing tests and linting must pass. No regressions.
  </verify>
  <done>
StateManager has getTemplateHashes/setTemplateHashes/getStaleTemplates methods. PageHashComputer has public hashContentString method. getDefaultState includes templateHashes key. All existing functionality preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for template hash methods</name>
  <files>
    tests/phpunit/unit/Store/StateManagerTest.php
  </files>
  <action>
Add a new test section to StateManagerTest.php after the existing "MODIFIED PAGES" section and before "FULL STATE". Use the same pattern as existing tests (setUp skip check, createStateManager helper).

**Tests to add (in a `TEMPLATE HASHES` section):**

1. `testGetTemplateHashesReturnsEmptyArrayByDefault` -- new manager, `getTemplateHashes()` returns `[]`

2. `testSetTemplateHashes` -- set hashes for `'Template:Person/semantic'` and `'Form:Person'` with `['generated' => 'sha256:abc', 'category' => 'Person']` structure. Assert both keys exist in `getTemplateHashes()`.

3. `testSetTemplateHashesPreservesExisting` -- set hash for `'Template:Person/semantic'`, then set hash for `'Template:Student/semantic'` in a second call. Assert both keys present (merge behavior, not replace).

4. `testSetTemplateHashesSetsGeneratedTimestamp` -- after `setTemplateHashes()`, call `getFullState()` and assert `'generated'` key is not null.

5. `testGetStaleTemplatesDetectsChangedHash` -- store `'Template:Person/semantic' => ['generated' => 'sha256:old', 'category' => 'Person']` via `setTemplateHashes()`. Call `getStaleTemplates()` with `['Template:Person/semantic' => ['generated' => 'sha256:new', 'category' => 'Person']]`. Assert `'Template:Person/semantic'` is in returned stale array.

6. `testGetStaleTemplatesReturnsEmptyWhenUnchanged` -- store and compare identical hashes. Assert empty result.

7. `testGetStaleTemplatesDetectsRemovedTemplates` -- store hash for `'Template:Person/semantic'` and `'Template:Deleted/semantic'`. Call `getStaleTemplates()` with only Person. Assert Deleted is in stale.

8. `testGetStaleTemplatesDetectsNewTemplates` -- store hash only for Person. Call `getStaleTemplates()` with Person AND Student. Assert Student is in stale (stored hash missing).

9. `testTemplateHashesIndependentOfPageHashes` -- set both `setPageHashes(['Category:Person' => 'hash1'])` and `setTemplateHashes(['Template:Person/semantic' => ['generated' => 'sha256:abc', 'category' => 'Person']])`. Assert both `getPageHashes()` and `getTemplateHashes()` return their respective data independently.

10. Update existing `testGetFullStateReturnsCompleteStructure` -- add `$this->assertArrayHasKey( 'templateHashes', $state )` assertion.

Follow the existing test file's PHPDoc and formatting conventions exactly (tab indentation, section headers with `/* === */` blocks).
  </action>
  <verify>
Run `composer test` -- all tests pass including new template hash tests. Run `php vendor/bin/phpunit tests/phpunit/unit/Store/StateManagerTest.php` specifically to confirm new tests execute.
  </verify>
  <done>
10 new/updated test methods covering: default state, set/get, merge behavior, stale detection (changed/unchanged/removed/new), independence from pageHashes, full state structure. All pass.
  </done>
</task>

</tasks>

<verification>
- `composer test` passes (parallel-lint, minus-x, phpcs, phpunit)
- `php vendor/bin/phpunit tests/phpunit/unit/Store/StateManagerTest.php` -- all tests pass
- StateManager::getDefaultState() includes `'templateHashes' => []`
- StateManager has 3 new public methods: setTemplateHashes, getTemplateHashes, getStaleTemplates
- PageHashComputer has 1 new public method: hashContentString
- All existing page hash methods work identically (no regression)
</verification>

<success_criteria>
- STATE-01 (partial): StateManager infrastructure for template-level hashing exists
- STATE-03 (full): Existing single-category state tracking works identically after changes
- Backward compatibility: Old state JSON without templateHashes key works via array_merge default
</success_criteria>

<output>
After completion, create `.planning/phases/09-state-management-refactor/09-01-SUMMARY.md`
</output>
